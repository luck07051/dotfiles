#!/bin/sh

# default install, remove ... command
install_cmd="${PKGMAN:-pacman} -S"
remove_cmd="${PKGMAN:-pacman} -Rns"
generate_local_packages_cmd="${PKGMAN:-pacman} -Qq"
terminal_cmd="${TERMINAL:-st} -t installer -e"

packages_list="${XDG_CONFIG_HOME:-$HOME/.config}/package-manager/packages"
# cache file
installed_packages="${XDG_CACHE_HOME:-$HOME/.cache}/package-manager/installed_packages"
# temp file
install_packages="/tmp/package-manager_install-packages"
remove_packages="/tmp/package-manager_remove-packages"
local_packages="/tmp/package-manager_local-packages"
install_cmd_file="/tmp/packages-manager_install_cmd"

# options
no_terminal=false

usage(){
	cat <<EOF
Usage: ${0##*/} [OPTION]... [FILE]
Manage packages with text file.

  -h, --help            display this help and exit
  -n, --noew-cache      remove old cache file
  -t, --no-terminal     don't uses extra terminal to install packages

Add or delete packages on FILE to install or uninstall packages.
Specify the install, remove... command by adding line start with '##'.

Example file:

##install_cmd="pacman -S"
##remove_cmd="pacman -Rns"
##generate_local_packages_cmd="pacman -Qq"
##terminal_cmd="st -t installer -e"
# line start with '#' will be ignore.
package-to-install
other-package-name
EOF
	exit
}

redir(){
	temp=$(mktemp)
	cat > "$temp"
	mv -f "$temp" "$1"
}

parse_config(){
	eval "$(sed -n 's/\s*##\s*\(.*\)$/\1/p' "$packages_list")"
}

update_installed_packages(){
	comm "$installed_packages" "$local_packages" -12 | redir "$installed_packages"
}

parse_packages(){
	temp_packages_list="$(sed 's/\s*#.*$//' "$packages_list" | tr ' ' '\n' |
		sed '/^\s*$/d' | sort | uniq)"

	echo "$temp_packages_list" | comm - "$installed_packages" -23 > "$install_packages"
	echo "$temp_packages_list" | comm - "$installed_packages" -13 > "$remove_packages"

	[ -s "$install_packages" ] && check_install_packages
	[ -s "$remove_packages" ] && check_remove_packages
}

check_install_packages(){
	# already installed packages
	temp_file="$(mktemp)"
	comm "$install_packages" "$local_packages" -12 > "$temp_file"

	if [ ! -s "$temp_file" ]; then
		rm "$temp_file"
		return
	fi

	# update installed packages
	cat "$installed_packages" "$temp_file" | sort | uniq | redir "$installed_packages"
	# update install packages
	comm "$install_packages" "$temp_file" -23 | redir "$install_packages"

	rm "$temp_file"
}

check_remove_packages(){
	# non exist packages
	temp_file="$(mktemp)"
	comm "$remove_packages" "$local_packages" -23 > "$temp_file"

	if [ ! -s "$temp_file" ]; then
		rm "$temp_file"
		return
	fi

	# update installed packages
	comm "$installed_packages" "$temp_file" -12 | redir "$installed_packages"
	# update install packages
	comm "$remove_packages" "$temp_file" -12 | redir "$install_packages"

	rm "$temp_file"
}

generate_install_command(){
	install_list="$(tr '\n' ' ' < "$install_packages")"
	remove_list="$(tr '\n' ' ' < "$remove_packages")"
	cat > "$install_cmd_file" << EOF
#/bin/sh
read_char() {
	stty -icanon -echo
	eval "\$1=\$(dd bs=1 count=1 2>/dev/null)"
	stty icanon echo
}
# prompt the cmd will be exec
echo 'The following commands will be execute:'
[ -s "$install_packages" ] && echo "  $install_cmd $install_list"
[ -s "$remove_packages" ] && echo "  $remove_cmd $remove_list"
printf 'Press <Enter> or y to continue.'
read_char ans
case \$ans in
	"\$(printf '\n')" | 'y') printf '\n\n' ;;
	*) exit
esac
# exec the cmd
[ -s "$install_packages" ] && $install_cmd $install_list
[ -s "$remove_packages" ] && $remove_cmd $remove_list
# update local_packages
$generate_local_packages_cmd > "$local_packages"
printf '\n\n'
# show the packages that not install or remove successfully
comm $install_packages $local_packages -23 | tr '\n' ' ' |
	xargs -r -I {} echo 'These package not been installed: {}'
comm $remove_packages $local_packages -12 | tr '\n' ' ' |
	xargs -r -I {} echo 'These package not been removed: {}'
# freezing if uses terminal
[ "\$1" = 'terminal' ] && echo '\nPress any key to finish' && read_char _
EOF
	chmod +x "$install_cmd_file"
}

update_installed_packages_after_install(){
	# add installed packages
	comm $install_packages $local_packages -12 | cat - "$installed_packages" |
		sort | uniq | redir "$installed_packages"
	# remove packages
	comm $remove_packages $local_packages -23 | comm - "$installed_packages" -13 |
		redir "$installed_packages"
}

# parse options
TEMP=$(getopt -o 'hnt' -l 'help,new-cache,no-terminal' -n "$0" -- "$@")
[ $? -ne 0 ] && exit 1
eval set -- "$TEMP"
unset TEMP
while true; do
	case "$1" in
		'-h'|'--help')        usage ;;
		'-n'|'--new-cache')   rm -f "$installed_packages"; shift ;;
		'-t'|'--no-terminal') no_terminal='true';          shift ;;
		'--')   [ $# -gt 2 ] && echo 'Too many args!' >&2 && exit 1
			[ -n "$2" ] && packages_list="$2"
			break ;;
		*) echo 'Internal error!' >&2; exit 1 ;;
	esac
done

# check the file
[ ! -f "$packages_list" ] && { echo 'Packages list not found.' >&2; exit 1; }
if [ ! -f "$installed_packages" ]; then
	mkdir -p "$(dirname "$installed_packages")"
	touch "$installed_packages"
fi

parse_config
$generate_local_packages_cmd | sort > "$local_packages"
update_installed_packages
parse_packages

if [ ! -s $install_packages ] && [ ! -s $remove_packages ]; then
	rm -f $install_packages $remove_packages $local_packages
	exit
fi

generate_install_command

if [ -z "$DISPLAY" ] || [ "$no_terminal" = 'true' ]; then
	$install_cmd_file
else
	$terminal_cmd $install_cmd_file 'terminal'
fi

update_installed_packages_after_install

rm -f $install_packages $remove_packages $local_packages $install_cmd_file
